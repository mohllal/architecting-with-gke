# Module 4: Persistent Data and Storage

- Kubernetes provides storage abstraction as ***volumes*** and ***persistent volumes***.
  - Volumes are the method by which Kubernetes attach storage to a pod. Some volumes are ***ephemeral***, which means they last only as long as the pod to which they are attached such as `ConfigMap` and `emptyDir`. Some volumes are ***persistent***, which means that they can outlive a pod. Regardless of type, volumes are attached to pods, not containers. If a pod isn't mapped to a node anymore, the volume isn't either.
  - Persistent volumes can be used for ***data that must outlive the life cycle of an individual pod***. In Kubernetes cluster, you will frequently find these volume types backend by *NFS volumes* or *Windows shares* or *persistent disk* from the underlying cloud provider. These types of volumes embody *block storage* or use *network file systems*. On GKE, these volumes are typically backed by Compute Engine persistent disks. They provide durable storage beyond the existence of a pod. ***A failing node or a pod shouldn't affect these volumes. If that happens, the volumes are simply unmounted from the failing pod***. Some of these volumes might already exist before the creation of the pod and can be claimed and mounted.
- Volumes allow containers within a pod to share data and are necessary for pods to be stateful.
- Kubernetes volume types:
  - The ***emptyDir (ephemeral, shares Pod's lifecycle)*** volume is simply an empty directory that allows the containers within the pod to read and write to and from it. It's created when a pod is assigned to a node, and it exists as long as the pod exists. However, it will be deleted if the pod is removed from a node for any reason. Kubernetes creates `emptyDir` volumes from the node's ***local disk*** or by using a ***memory band file system***.
  - The ***ConfigMap*** resource provides a way to inject application configuration data into pods from Kubernetes. ***The data stored in config map object can be referenced in a volume. As if it were a tree of files and directories***, the applications can then consume the data.
  - The ***Secret*** is similar to configMaps. It can be used to store sensitive information such as password, token, and SSH keys. Just like configMap, a secret volume is created to pass sensitive information to the pods. ***These secret volumes are backed by in-memory file systems. So the secrets are never written to nonvolatile storage, and it's a common practice to obfuscate the values that go into secrets using the familiar base-64 encoding***.
  - The ***downwardAPI*** volume type is used to make downward API data available to applications. ***It's a way container skin learn about their pod environment***.
- A `volumes` section is added under the pod spec. The volume is named and fields are configured with the access details. In order to mount the volume to a container, the volume `name` and `mountPath` must be specified under the `volumeMounts` field for the container.
- ***The volume is created during the part creation. After the volume is created, it's available to any container in the pod before the containers are brought online***. After the volume is attached to a container, the data in the volume is mounted into a container's file system.
- A persistent volume in contrast has a life cycle of its own, independent of the pod. Kubernetes persistent volume objects abstract *storage provisioning* from *storage consumption*. Persistent storage makes it possible to deal with failures and allow for dynamic rescheduling of components without loss of data.
- Google Cloud's Compute Engine services use persistent disk for virtual machines disks and Kubernetes engine uses the same technology for persistent volumes. Persistent disks are ***network-based block storage*** that can provide durable storage.
- The ***PersistentVolume*** abstraction has two components; ***PersistentVolume*** and ***PersistentVolumeClaim***.
  - ***PersistentVolumes*** are *durable and persistent storage resources* managed at the cluster level. Although these cluster resources are *independent of the pods lifecycle*, a pod can use these resources during its lifecycle. However, if a pod is deleted, a PersistentVolume and its data continue to exist. *These volumes are managed by Kubernetes and can be manually or dynamically provisioned*. GKE can use Compute Engine persistent disk as Persistent Volumes.
  - ***PersistentVolumeClaims*** are request and claims made by pods to use PersistentVolumes. Within a PersistentVolumeClaim object, we define a *volume size*, *access mode*, and *storage class*.
- GKE has a *default* storage class name standard to use the *Compute Engine standard Persistent Disk type*. In GKE clusters, a ***PVC with no defined storage class will use this default storage class*** and provide storage using a standard Persistent Disk.
- The access modes for PV or PVC determines *how this volume can be read from or written to*. The types of access modes that are available depend on the volume type:
  - `ReadWriteOnce` mounts the volume as read-write to a single node.
  - `ReadOnlyMany` mounts a volume as read-only to many nodes.
  - `ReadWriteMany` mounts volumes as read-write too many nodes.
- GCP persistent disks do not support `ReadWriteMany` access mode. Some other network volume types such as NFS do support the `ReadWriteMany` access mode.
- ***In order for the persistent volume claims to claim the persistent volume, the storage class names and access modes must match***. Also, the amount of storage requested in a persistent volume claim must be within a persistent volume storage capacity.
- ***If there isn't an existing persistent volume to satisfy the persistent volume claims, Kubernetes will try to provide a new one dynamically***. By default, Kubernetes will try to dynamically provision of persistent volume if the persistent volume claims storage class name is defined and an appropriate persistent volume does not already exist. ***If a matching persistent volume already exist, Kubernetes will bind it to the claim***.
- ***By default, deleting the persistent volume claim will also delete the provisioned persistent volume***. Using `persistentVolumeReclaimPolicy: Retain` will retain the persistent volume even after its claim has been deleted. In general, persistent volume claims should be deleted then their underlying persistent volume is no longer required.
- We can improve the availability of Compute Engine persistent disk by deploying them as regional persistent disk. ***Regional persistent disks replicate data between two zones in the same region, which improves availability***. A regional persistent disk can be launched manually or dynamically and provisioned by configuring additional fields in a storage class. To use regional persistent disk in Kubernetes, a storage class must specifies `replication-type: regional-pd` in its definition.
- ***StatefulSets*** are useful for stateful applications. ***StatefulSets*** run and maintain a set of pods just like *Deployments* do. A stateful set object defines a desired state and its controller achieves it. However, it maintains a ***persistent identity for each pod***. Each pod in a StatefulSet maintains a persistent identity and has an ***ordinal index*** with the relevant pod name, a ***stable host name*** and ***stable identified persistent storage*** that is linked to the ordinal index.
- What's an ***ordinal index***? It's just ***a unique sequential number that is assigned to each pod in the StatefulSet***. This number defines the pods position in the sets sequence of pods. Deployment, scaling and updates are ordered using the ordinal index of the pods within a stateful set.
- If we want to launch pods in parallel without waiting for the pods to maintain running and ready state, we can change the pod management policy to *parallel*.
- StatefulSets use a ***unique persistent volume claim for each pod so that each pod can maintain its own individual state***. It must have reliable long-term storage to which no other pods write. These persistent volume claims use `ReadWriteOnce` access mode for applications.
- Kubernetes provides an abstraction called ***persistent volumes***. This abstraction, let's a Pod claim of volume of certain size or of a certain name from a pool of storage *without forcing to define the storage type details inside the Pod specification*.
- Using ***ConfigMap*** to store *configuration files*, *command-line arguments*, *environment variables*, *port numbers*, and other configuration artifacts and make them available inside containers.
- ConfigMaps can be created from literal values, files, and directories using a simple `kubectl create configmap [NAME] [DATE]` command. These data sources contain ***key-value pairs***.
- `kubectl create configmap [NAME] --from-literal=[key=value]` command is used to create a `configMap` from a literal value.
- `kubectl create configmap [NAME] --from-file=[path]` command is used to create a `configMap` from a file with the key equals the file name.
- Pods are referred to `ConfigMap` in three ways: As a ***container environment variable***, in ***Pod commands***, or by ***creating a Volume***.
- After the container environment variables are defined, they can be used inside Pod manifest command using this syntax `$(VARIABLE_NAME)`.
- ***`ConfigMap` can be added into an ephemeral volume***. All the data from the `ConfigMap` is stored in the volume *as files*, and then this volume is mounted to the container using the `mountPath` directory.
- ***Each nodes `kubelet` periodically syncs with `ConfigMap` to keep the `ConfigMap` volume updated***. ***When a `ConfigMap` volume is already mounted and the source `ConfigMap` is changed, the projected keys are eventually updated on the order of seconds or minutes***. The values of environment variables are inserted into a Pod at the time of the Pod's birth; the `kubelet` has no way to reach into the Pod and modify these values later.
- Secrets manage sensitive information in their own control plane. ***Secrets also helped to ensure Kubernetes doesn't accidentally output these data to logs***.
- There are three types of Secrets:
  - The ***generic*** secret type is used when creating secrets from files, directories or literal values.
  - The ***TLS*** secret type uses an existing *public-private encryption key pair*. To create one of these, we must give Kubernetes the public key certificate encoded in `PEM` format, and we must also supply the private key of that certificate.
  - The ***Docker registry*** secret type can be used to *pass credentials for an image registry to `kubelet` so it can pull a private image from the Docker registry on behalf of the pod*.
- In Secrets, we supply values as `base64` encoded strings. ***`base64` encoding is not encryption***. These encoded strings can then be used in secret manifest. Secrets can be consumed as environment variables in a pod by its containers and they are automatically decoded.
- Secrets can also be consumed by creating a secret volume in a pod. Just like `ConfigMap`, `kubelet` periodically syncs with Secrets to keep a secret volume updated. If a secret that is already attached as a volume is changed, the keys and values are eventually updated.
