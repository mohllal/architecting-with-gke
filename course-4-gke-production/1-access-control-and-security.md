# Module 1: Access Control and Security in Kubernetes and Google Kubernetes Engine

- In Kubernetes, there are two main types of users. *Normal users* and *Kubernetes service accounts*. Normal users are *managed outside* of Kubernetes, that is Kubernetes relies on *external identity services*. Kubernetes service accounts provide an *identity for processes in a pod* and are used to interact with the Kubernetes cluster.
- ***In Kubernetes, every namespace has a default Kubernetes service account***. When processes in containers within a pod communicate with the cube API server, they identify themselves as a Kubernetes service account.
- In Kubernetes 1.8 and higher, thanks to the implementation of RBAC, *service accounts have no default permissions or access tokens*.
- After an account is authenticated, there are two main ways to authorize what that account can do:
  - ***Cloud Identity and Access Management (Cloud IAM)***: Cloud IAM is the access control system for managing GCP resources. It grants permissions to users to perform operations at the *project* and *cluster* levels. In other words, ***outside the Kubernetes clusters.***
  - ***Kubernetes Role-Based Access Control (RBAC)***: Kubernetes RBAC, gives access control ***inside the Kubernetes clusters*** at the cluster level and the namespace level. It allows creating fine tune rules in granular access to resources within the cluster.
- In Kubernetes, the API server listens for remote requests using HTTPS on port 443. Each request must be authenticated before it's acted upon. The API server can perform this authentication using various methods:
  - *OpenID connect* tokens: OpenID connect is a simple identity layer on top of the *OAuth 2.0* protocol. It lets clients verify the identity of an end user by crewing an authorization server.
  - *x509* client certs
  - Basic authentication using *static passwords*.
- Three elements are defined in Cloud IAM access control; ***who, what and which***. Who, refers to *the identity of the person making the request*. What, refers to the *set of permissions that are granted*, and which, refers to *which resources this policy applies to*.
- ***GCP permissions are grouped into roles*** based on common user flows. *Permissions can't be individually assigned to members. Instead, members are assigned roles*. Every operation on a GCP resource is performed using an API call, for which access is controlled using a permission. If the member trying to do the operation doesn't have the permission needed by the API call, it gets denied.
- The roles names consists of an abbreviated name for a *GCP service*, a *kind of GCP resource*, and a *verb*.
- A Cloud IAM policy is a list of bindings, and in each binding a set of members is bound to one or more roles. *Cloud IAM policies applied at higher levels of a GCP organizational hierarchy are inherited by resources lower down that hierarchy*.
- There are three kinds of roles in Cloud IAM, ***primitive***, ***predefined***, and ***custom***:
  - *Primitive* roles existed before the introduction of Cloud IAM but can still be used with Cloud IAM. *These roles can be used to grant users global, project-level access to all GCP resources within a project*. There are three primitive roles.
    - The ***Viewer*** role, permits *read-only* actions such as viewing existing resources or data across the whole project.
    - The ***Editor*** role. In addition to all of your permissions, the Editor role is allowed to *modify existing resources*.
    - The ***Owner*** role, has all of the editor permissions, plus has the right to *manage roles and permissions and set up billing for a project*.
  - *Predefined* roles are the second type of Cloud IAM role. GKE provides several predefined Cloud IAM roles that provide granular access to Kubernetes engine resources.
  - *Custom* roles are the third type of Cloud IAM role. Custom roles are user-defined roles with more granular control by specifying each individual permission that will make up the role.

- GKE IAM predefined roles:
  - The ***GKE Viewer*** role gives read-only access as might be needed for auditing.
  - The ***GKE Developer*** role is suited to developers and release engineers. It grants full control to all resources within a cluster.
  - The ***GKE Admin*** role gives full access to clusters and the Kubernetes engine resources inside the clusters. Example users are project owners, system administrators, and on-call engineers.
  - The ***GKE Cluster Admin*** role is used to create, delete, update, and view clusters, but provides no access to Kubernetes resources.
  - The ***GKE Host Service Agent User*** is another role intended for use by service accounts and is used for network management inside a shared VPC environment.
- In GKE environments, ***RBAC extends Cloud IAM security, by offering control over Kubernetes resources within the cluster***, supplementing the control provided directly by Cloud IAM, which allow us to control access of the GKE and cluster level.
- There are three main elements to Kubernetes role-based access control: ***subjects***, ***resources***, and ***verbs***. With Kubernetes RBAC, you define what operations, the verbs, can be executed over which objects, the resources, by whom, the subjects. These three elements can be connected by creating two types of RBAC API objects: ***Roles*** and ***RoleBindings***. *Roles connect API resources and verbs. RoleBindings connect Roles to subjects*. Roles and RoleBindings can be applied at the cluster or namespace level.
- In Kubernetes, there are two types of roles: ***Role***, and ***ClusterRole***. RBAC Roles are defined at the namespace level, and RBAC ClusterRoles are defined at the cluster level.
- There is another older authorization option in Kubernetes, ***attribute-based access control or ABAC***. RBAC is simpler and easier to work with than RBAC. Google recommends that use RBAC and disable ABAC. ABAC is disabled by default in GKE clusters created with Kubernetes 1.8 later.
- In GKE, all the master components such as the API server, etcd database, and Controller Manager are managed by Google. ***Each cluster has its own root Certificate Authority (CA)***. An internal Google service manages the root keys for the CA. Secure communications between the master and nodes at a cluster, relies on the shared root of trust provided by the certificates issued by the CA.
- The Kubernetes `api-server` and the `kubelet` use secured network communications protocols, namely TLS and SSH when they communicate with each other. They use certificates issued by the clusters root CA to support those protocols.
- The credentials rotation process starts by creating a new IP address for the cluster master along with its existing IP address. New credentials are issued to the control plane. Note that the API server will not be available during this period although pods continue to run. After the masters reconfigured, the nodes are automatically updated by GKE to use the new IP and credentials. This causes GKE to also automatically upgrade the node version to the closest supported version. All of the API clients outside the cluster must also be updated to use the new credentials. Rotation must be completed for the cluster master to start serving with the new IP address and new credentials, and remove the old IP address and old credentials. If the rotation is not completed manually, GKE will automatically complete the rotation after seven days.
- A `securityContext` is a set of security settings defined in a pod specification. It defines restrictions on what the containers in a pod can do and also enforces the use of specific security measures.
- In a Linux system, ***zero is the privileged root user's user ID***. Taking away root privilege from the code running inside the container limits what it can do in case of compromise.
- The `PodSecurityPolicy` controller is an admission controller that validates or modifies requests to create or update pods against one or more security policies. The `PodSecurityPolicy` admission controller acts on the creation and modification of pods, and determines whether the pod should be admitted based on the requested security context, and the available pod security policies.
- Recommended security best practices:
  - ***Use Google's container optimized OS for the node OS***. Unlike a general purpose Linux distribution, the container optimized OS implements a minimal read-only file system. Performs system integrity checks and implements firewalls, audit logging, and automatic updates.
  - ***Enable node auto upgrades*** to keep all of the nodes running the latest version of Kubernetes.
  - ***Run private clusters, which contain nodes without external IP addresses***. Also choose to run the cluster master for a private cluster without a publicly reachable end point using Master authorized networks. Using private clusters with master authorized networks, makes your cluster master reachable only by the specific address ranges that you choose.
  - ***Protect the secrets by using encrypted secrets***. To store sensitive configuration information rather than storing them in `ConfigMap`s.
  - Whenever possible, ***grant privilege to groups rather than individual users***. This applies both to Cloud IAM which lets grant rules to Google groups, as well as Kubernetes RBAC which lets granting roles to Kubernetes groups.
